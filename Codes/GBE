from pyomo.environ import *
import numpy as np
import math

# Final Model
num_count=8
p_save=np.zeros([num_count,5])
q_save=np.zeros([num_count,5])
m_save=np.zeros([num_count,5])
a_save=np.zeros([num_count,5])
b_save=np.zeros([num_count,5])
c_save=np.zeros([num_count,5])
for num in range (num_count):
    for flag_1 in range (1):
        
        target=10000+(flag_1-1)*2500
    
        model = ConcreteModel()
        # declare decision variables
        cap_i=6600
        rate=(target-cap_i)/4
        revenue_data_1=[0.701, 0.760, 0.792, 0.679, 0.634, 0.655, 0.726, 0.968, 1.141, 
                        1.752, 1.900, 1.903, 2.048, 2.366, 2.936, 3.263,3.750,3.833,3.806,3.616,4.284,10.323,14.514,18.40]
        #except for original scenario
        if flag_1 >0:
            for i in range (4):
                if i == 0:
                    revenue_init=14.514
                revenue_data_1.append((cap_i+rate*(i+1))/cap_i*14.514)
                revenue_init=revenue_init+rate/cap_i*14.514
        L=len(revenue_data_1)

        tem_1=L+4*num-1
        tem_2=L+4*(num+1)-2
        final_tem=L+4*7-1

        model.q = Var(domain=NonNegativeReals)
        model.p = Var(domain=NonNegativeReals)
        model.a = Var(domain=NonNegativeReals)
        model.c = Var(domain=Reals)
        model.m = Var(domain=NonNegativeReals)
        model.b = Var(domain=Reals)

        I_data=[]
        revenue_data=[]
        t_data=[]
        for i in range (L):
            revenue_data.append(sum(revenue_data_1[max(0,i-19):i+1]))
            t_data.append(i)
        if flag_1 ==0:
            revenue_data_original=revenue_data
        
        
        for i in range (1000):
            if i<20.9:
                I_data.append(0)
            else:
                I_data.append(1)

        def obj_rule(model):
            objectives=0
            for i in range (0,L):
                cc=sum(1+model.c*exp(model.b*(j-model.a))*I_data[j] for j in range (0,i+1))
                value=model.m*(1-exp(-(model.p+model.q)*cc))/(1+model.q/model.p*exp(-(model.p+model.q)*cc))
                objectives=objectives+(value-revenue_data[i])**2
            return objectives

        # declare objective
        model.profit = Objective(rule = obj_rule, sense=minimize)


        # declare constraints
        model.laborA11 = Constraint(expr = model.a <= 20.999)
        model.laborA12 = Constraint(expr = model.a >= 19.9)
        model.laborA21 = Constraint(expr = model.c <= 100)
        model.laborA22 = Constraint(expr = model.c >= -100)
        model.laborA31 = Constraint(expr = model.b >= -1)
        model.laborA32 = Constraint(expr = model.b <= 0)

        rate_1=10
        rate_2=10
        rate_3=10
        
        model.laborB11 = Constraint(expr = model.p <= 1.41/1e3*rate_2)
        model.laborB12 = Constraint(expr = model.p >= 1.41/1e3/rate_2)
        model.laborB21 = Constraint(expr = model.q <= 1.26/10*rate_3)
        model.laborB22 = Constraint(expr = model.q >= 1.26/10/rate_3)
        
        if num < 7:
            model.laborC1 = Constraint(expr = sum(1+model.c*exp(model.b*(j-model.a))*I_data[j] for j in range (0,tem_1+1)) <= (-log(model.p/model.q))/(model.p+model.q))
            model.laborC2 = Constraint(expr = sum(1+model.c*exp(model.b*(j-model.a))*I_data[j] for j in range (0,tem_2+1)) >= (-log(model.p/model.q))/(model.p+model.q))   
        else:
            model.laborC1 = Constraint(expr = sum(1+model.c*exp(model.b*(j-model.a))*I_data[j] for j in range (0,tem_1+1)) <= (-log(model.p/model.q))/(model.p+model.q))
       

        
        solver = SolverFactory('ipopt')
        solver.options['max_iter']= 30000
        solver.solve(model)


        print('\nProfit = ', model.profit())
        print('m = ', model.m())
        print('p = ', model.p())
        print('q = ', model.q())
        print('a = ', model.a())
        print('b = ', model.b())
        print('c = ', model.c())
        
        m_init=model.m()
        
        
        p_save[num,flag_1]=model.p()
        q_save[num,flag_1]=model.q()
        m_save[num,flag_1]=model.m()
        a_save[num,flag_1]=model.a()
        b_save[num,flag_1]=model.b()
        c_save[num,flag_1]=model.c()
        
        p=p_save[num,flag_1]
        q=q_save[num,flag_1]
